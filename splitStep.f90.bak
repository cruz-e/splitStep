PROGRAM splitStep

   
!USE nrtype; USE nrutil, ONLY : assert,swap
!USE nr
USE constantsMod
USE inputParametersMod
USE inputFileMod
USE inputFunctions
USE subroutines

!IMPLICIT NONE

INTEGER :: iz,n

REAL(DP) :: z,w
REAL(DP) :: fexpr,fexpi
REAL(DP) :: Puzt

REAL(DP), ALLOCATABLE :: deltaf(:)
REAL(DP), ALLOCATABLE :: u0w(:,:),uzt(:,:),uzw(:,:)
REAL(DP), ALLOCATABLE :: u0tp(:,:)

 CHARACTER(LEN=50)  :: outputPowerFile

! ###################################################
! BEGIN
! ###################################################

 write(6,*)
 write(6,*)"START RUNNING splitStep.f90"
 write(6,*)

 CALL parseParamFile
 write(6,*)'case ', case
 write(6,*)'inputFunction ', inputFunction

 outputPowerFile=TRIM(case)//'_power'
 OPEN(UNIT=12,FILE=outputPowerFile,FORM='FORMATTED', STATUS='UNKNOWN')

! ###############
! Input Functions
 allocate(u0t(2,0:nSteps-1),t(0:nSteps-1))
 allocate(u0w(2,0:nSteps-1))
 
 SELECT CASE(inputFunction)
  CASE("stepFunction")
   call stepFunction()
  CASE("Gaussian")
   call gaussianFunction()
 END SELECT

!### Perform Discrete Fourier Transform
  write(6,*)"Performing Discrete Fourier Transform"
  call sdft(1,nSteps,dt,u0t,u0w)
! call four1_dp(Ht,1)
!

!### Check Parseval Theorem
 call parsevalTheorem(u0t,u0w)
!###

 allocate(deltaf(0:nSteps-1))
!### Arrange Frequency Data
 call arrangeFreqData(dt,deltaf)
!###

 allocate(u0tp(2,0:nSteps-1))
!### Perform Inverse Discrete Fourier Transform
!        F^{-1}(H(f)) = h(t)
  write(6,*)"Performing Inverse Discrete Fourier Transform"
  call sdft(-1,nSteps,dt,u0w,u0tp)
  do k=0,nSteps-1 
     t(k)= tmin + k*dt
     write(6,'(3f16.6)')t(k),u0tp(1,k),u0tp(2,k) 
  end do
!###


!### SPLIT-STEP METHOD
!  CASE:  
!  u(zeta,w)= u(0,w)exp{I b_2 w^2 z/2}
!  u(zeta,w)= u(0,w)exp{I To^2 w^2 zeta/2}
!    with zeta=z/L_D  ; To=1
!     zeta-> z
  dz=.1
  write(6,*)'nzSteps ',nzSteps
  write(6,*)'iz, z'
  do iz=0,5
     allocate(uzw(2,0:nSteps-1),uzt(2,0:nSteps-1))
     z= zmin + iz*dz*10
     write(6,*)iz,z
     do n=0,nSteps-1 
        w=2.d0*pi*(deltaf(n))
!           if(n<=(nSteps/2)) w=2.d0*pi*(deltaf(n))
!           if((nSteps/2)<n) w=2.d0*pi*(-deltaf(n))
!            u0w(1,n)= sqrt(2.d0*pi)*T0*exp(-(T0**2)*(w**2)/2.d0)
!            u0w(2,n)= 0.d0 
        arg= (T0**2)*(w**2)*z/2.d0
        fexpr= cos(arg)
        fexpi= sin(arg)
        uzw(1,n)= u0w(1,n)*fexpr  - u0w(2,n)*fexpi
        uzw(2,n)= u0w(1,n)*fexpi  + u0w(2,n)*fexpr
!        write(*,'(5f16.6)')z,uzw(1,n),uzw(2,n)
     end do
!     write(6,*)"Perform Inverse Discrete Fourier Transform"
     call sdft(-1,nSteps,dt,uzw,uzt)
     do k=0,nSteps-1
        Puzt= (uzt(1,k)**2 + uzt(2,k)**2)
        write(12,'(5f16.6)')z,t(k),uzt(1,k),uzt(2,k),Puzt
     end do

     write(12,*)""
     write(12,*)""
    deallocate(uzw,uzt)
  end do

  write(6,*)
  write(6,*)'Power output-file: ',outputPowerFile
  write(6,*)

 deallocate(u0t,deltaf,t)


!##########
 write(6,*)""
 write(6,*)"END PROGRAM splitStep"
!#################################
END PROGRAM splitStep
!#################################



